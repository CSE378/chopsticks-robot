#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          turnMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          jointMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          pinchMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------Variables

// Bluetooth Messages
const string BODY_START = "BODY_START";
const string ARM_INIT = "ARM_INIT"
const string ARM_START = "ARM_START";
const string ARM_EXIT = "ARM_EXIT";

// Movement variables
int turnPower = 50;
int turnTime = 2500;
int jointRatio = 1; // Account for difference in distances to robot
int jointPower = -30;
int jointTime = 600;
int pinchPower = 18;
int pinchTime = 250;
int pinchBackTime = 250;
const int PAUSE_TIME = 700;	// Pause time between steps of algorithm

// RobotC doesn't hoist functions, solve
// this by declaring functions above.
void toDefaultPosition();
void toSushiPosition();
void pinchChopsticks();
void releaseChopsticks();
void messageBody();
void waitForMessage();
void init();
void pickUpSushi();
void dropSushi();
void exit();
void nextArmCycle();

//--------------------------------------------------Movement
void turnArm(int power, int time){
	motor[turnMotor] = power;
	wait1Msec(time);
	motor[turnMotor] = 0;
}

// Moves the arm into place.
void toSushiPosition(){
	// Turn to sushi
	//turnArm(turnPower, 90);

	// Joint down to sushi
	motor[jointMotor] = jointPower;
	wait1Msec(jointTime * jointRatio);
	motor[jointMotor] = 0;
};
void toDropPosition(){

	// Turn back
	turnArm(-turnPower, turnTime);
}
// Moves arm configuration into default position after dropping.
void toDefaultPosition(){
	// Turn back
	turnArm(turnPower, turnTime);
};
// Moves chopsticks into pinching position.
void pinchChopsticks(){
	motor[pinchMotor] = pinchPower;
	wait1Msec(pinchTime);
	motor[pinchMotor] = 0;
};
// Releases chopsticks from pinching position.
void releaseChopsticks(){
	motor[pinchMotor] = -pinchPower;
	wait1Msec(pinchBackTime);
	motor[pinchMotor] = 0;
};

//--------------------------------------------------Bluetooth

// COMMAND    | CODE |  TRANSLATION
// -----------|------|-----------------------
// BODY_START |  +3  |  Run body cycle
// ARM_INIT   |  +2  |  Initialize arm
// ARM_START  |  +1  |  Run arm cycle
// ARM_EXIT   |  -1  |  Exit arm program

// Sends a BODY message to the body controller.
void messageBody(const string command) {
	// RobotC bugs out if switch has one case,
  // just use if check for now.
	if (strcmp(command, BODY_START) == 0) {
		//sendMessageWithParm(1, jointRatio);
			const int kMaxSizeOfMessage = 5;
			ubyte nTransmitBuffer[kMaxSizeOfMessage];
			nTransmitBuffer[0] = 3;

			TFileIOResult messageOut = cCmdMessageWriteToBluetooth(nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			return;
	}
};
// Pauses the program while we wait for a
// message from the body controller.
void waitForMessage(){
	while(cCmdMessageGetSize(mailbox1) <= 0) {
		nxtDisplayTextLine(0, "NO MESSAGE", message);
		wait1Msec(100);
	}
};

// Parses an ARM command coming from the
// body controller
void parseMessage() {
	const int kMaxSizeOfMessage = 5;
	ubyte nReceiveBuffer[kMaxSizeOfMessage];

	TFileIOResult messageIn = cCmdMessageRead(nReceiveBuffer, kMaxSizeOfMessage, mailbox1);
	switch(nReceiveBuffer[0]){
		case 1:
			ClearMessage();
			nextArmCycle();
			break;
		case -1:
			ClearMessage();
			exit();
			break;
		default:
			ClearMessage();
			nextArmCycle();
	}
}

//--------------------------------------------------Utils

// Initialize system variables
void init();
// Pick up the sushi.
void pickUpSushi() {
	toSushiPosition();
	wait1Msec(PAUSE_TIME);
	pinchChopsticks();
};
// Drops the sushi.
void dropSushi() {
	toDropPosition();

	// Move arm down
	motor[jointMotor] = jointPower;
	wait1Msec(200);
	motor[jointMotor] = 0;

	releaseChopsticks();

	// Move arm up
	motor[jointMotor] = -jointPower;
	wait1Msec(300);
	motor[jointMotor] = 0;

	toDefaultPosition();
};
void checkIfPickedUp(){
			const int kMaxSizeOfMessage = 5;
			ubyte nTransmitBuffer[kMaxSizeOfMessage];
			nTransmitBuffer[0] = 4;

			TFileIOResult messageOut = cCmdMessageWriteToBluetooth(0, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			messageOut = cCmdMessageWriteToBluetooth(1, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			messageOut = cCmdMessageWriteToBluetooth(2, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			messageOut = cCmdMessageWriteToBluetooth(3, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);

			while(cCmdMessageGetSize(mailbox1) <= 0) {
				nxtDisplayTextLine(0, "CHECKING", message);
				wait1Msec(100);
			}

			ubyte nReceiveBuffer[kMaxSizeOfMessage];

			TFileIOResult messageIn = cCmdMessageRead(nReceiveBuffer, kMaxSizeOfMessage, mailbox1);

			const int successCode = nReceiveBuffer[0];
			ClearMessage();
			if(successCode == 0) {
				// Release pinch
				releaseChopsticks();
				nextArmCycle();
			}
			if(successCode == 1) {
				return;
			}

}
// Exit the program
void exit(){
	powerOff();
};


//--------------------------------------------------Main
// Runs a single cycle of the arm program.
//
// 1) Wait to receive message from the body.
// 		- If exit message, exit the program
// 2) If pickup message, pickup the sushi.
// 3) Drop Sushi at desired location
// 4) Move to default position
// 5) Message body
// 6) Repeat loop
void nextArmCycle() {
	pickUpSushi();
	// Joint back up
	motor[jointMotor] = -jointPower;
	wait1Msec(jointTime * jointRatio);
	motor[jointMotor] = 0;
	checkIfPickedUp();
	dropSushi();

	messageBody(BODY_START);

	waitForMessage();
	parseMessage();
};

task main()
{
	setBluetoothOn();
	waitForMessage();
	parseMessage();
}
