#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          turnMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          jointMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          pinchMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------Variables

// Bluetooth Messages
const string BODY_START = "BODY_START";
const string ARM_INIT = "ARM_INIT"
const string ARM_START = "ARM_START";
const string ARM_EXIT = "ARM_EXIT";

// Movement variables
int turnPower = 50;
int turnTime = 2500;
int jointRatio = 1; // Account for difference in distances to robot
int jointPower = -30;
int jointTime = 1200;
int pinchPower = 20;
int pinchTime = 250;

// RobotC doesn't hoist functions, solve
// this by declaring functions above.
void toDefaultPosition();
void toSushiPosition();
void pinchChopsticks();
void releaseChopsticks();
void messageBody();
void waitForMessage();
void init();
void pickUpSushi();
void dropSushi();
void exit();
void nextArmCycle();

//--------------------------------------------------Movement
void turnArm(int power, int time){
	motor[turnMotor] = power;
	wait1Msec(time);
	motor[turnMotor] = 0;
}

// Moves the arm into place.
void toSushiPosition(){
	// Turn to sushi
	//turnArm(turnPower, 90);

	// Joint down to sushi
	motor[jointMotor] = jointPower;
	wait1Msec(jointTime * jointRatio);
	motor[jointMotor] = 0;
};
void toDropPosition(){
	// Joint back up
	motor[jointMotor] = -jointPower;
	wait1Msec(jointTime * jointRatio);
	motor[jointMotor] = 0;

	// Turn back
	turnArm(-turnPower, turnTime);
}
// Moves arm configuration into default position after dropping.
void toDefaultPosition(){
	// Turn back
	turnArm(turnPower, turnTime);
};
// Moves chopsticks into pinching position.
void pinchChopsticks(){
	motor[pinchMotor] = pinchPower;
	wait1Msec(pinchTime);
	motor[pinchMotor] = 0;
};
// Releases chopsticks from pinching position.
void releaseChopsticks(){
	motor[pinchMotor] = -pinchPower;
	wait1Msec(pinchTime);
	motor[pinchMotor] = 0;
};

//--------------------------------------------------Bluetooth

// COMMAND    | CODE |  TRANSLATION
// -----------|------|-----------------------
// BODY_START |  +3  |  Run body cycle
// ARM_INIT   |  +2  |  Initialize arm
// ARM_START  |  +1  |  Run arm cycle
// ARM_EXIT   |  -1  |  Exit arm program

// Sends a BODY message to the body controller.
void messageBody(const string command) {
	// RobotC bugs out if switch has one case,
  // just use if check for now.
	if (strcmp(command, BODY_START) == 0) {
		sendMessage(3);
	}
};
// Pauses the program while we wait for a
// message from the body controller.
void waitForMessage(){
	while(cCmdMessageGetSize(mailbox1) <= 0) {
		nxtDisplayTextLine(0, "NO MESSAGE", message);
		wait1Msec(100);
	}
	//waitUntil(SensorValue[touchSensor] > 0.7);
	//nextArmCycle();
};

// Parses an ARM command coming from the
// body controller
void parseMessage() {
	switch(message){
		case 2:
			ClearMessage();
			toDefaultPosition();
			break;
		case 1:
			jointRatio = messageParm[1];
			ClearMessage();
			nextArmCycle();
			break;
		case -1:
			ClearMessage();
			exit();
			break;
		default:
			nextArmCycle();
	}
}

//--------------------------------------------------Utils

// Initialize system variables
void init();
// Pick up the sushi.
void pickUpSushi() {
	toSushiPosition();
	pinchChopsticks();
};
// Drops the sushi.
void dropSushi() {
	toDropPosition();

	// Move arm down
	motor[jointMotor] = jointPower;
	wait1Msec(600);
	motor[jointMotor] = 0;

	releaseChopsticks();

	// Move arm up
	motor[jointMotor] = -jointPower;
	wait1Msec(650);
	motor[jointMotor] = 0;

	toDefaultPosition();
};
// Exit the program
void exit(){
	powerOff();
};


//--------------------------------------------------Main
// Runs a single cycle of the arm program.
//
// 1) Wait to receive message from the body.
// 		- If exit message, exit the program
// 2) If pickup message, pickup the sushi.
// 3) Drop Sushi at desired location
// 4) Move to default position
// 5) Message body
// 6) Repeat loop
void nextArmCycle() {
	pickUpSushi();
	dropSushi();

	messageBody(BODY_START);

	waitForMessage();
};

task main()
{
	setBluetoothOn();
	waitForMessage();
	//waitForMessage();
	parseMessage();
}
