#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          leftWheel,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightWheel,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------Variables

// Bluetooth Messages
const string BODY_START = "BODY_START";
const string ARM_INIT = "ARM_INIT"
const string ARM_START = "ARM_START";
const string ARM_EXIT = "ARM_EXIT";

// Movement Variables
const int SEARCH_TIME = 3000; // Stop searching for sushi after this much time
const int speed = -10;	// Make negative since it will otherwise go backwards
const int seeBufferTime = 200 // Buffer time after seeing object to center itself
int distanceFromPlate = 0; // Track distance travelled forward from plate with time
const int PAUSE_TIME = 700;	// Pause time between steps of algorithm

// Sushi Sensor Threshold
const int sushiValue = 17;
const int errorMargin = 5;
int jointRatio = 1;

// RobotC doesn't hoist functions, solve
// this by declaring functions above.
void moveWheels();
void stopWheels();
bool seeSushi();
void messageArm();
void waitForMessage();
void init();
void toNextSushi();
void exit();
void runSushiRobot();
void nextBodyCycle();

//--------------------------------------------------Movement

// Moves the robot forward.
void moveWheels(int power) {
	motor[leftWheel] = power;
	motor[rightWheel] = power;
};
// Stops the robot.
void stopWheels() {
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
};

//--------------------------------------------------Vision

// Returns true if the light sensor detects
// sushi, and false otherwise.
bool seeSushi() {
	return SensorValue[sonarSensor] <= sushiValue;
};

void updateJointRatio() {
	// Wait to stabilize value
	wait1Msec(500);
	// Test this adaptive code later
	jointRatio = sushiValue / SensorValue[sonarSensor]
	// For now, just make it 1
	jointRatio = 1;
}

//--------------------------------------------------Bluetooth

// COMMAND    | CODE |  TRANSLATION
// -----------|------|-----------------------
// BODY_START |  +3  |  Run body cycle
// ARM_INIT   |  +2  |  Initialize arm
// ARM_START  |  +1  |  Run arm cycle
// ARM_EXIT   |  -1  |  Exit arm program

// Sends an ARM message to the arm controller.
void messageArm(const string command) {
	if (strcmp(command, ARM_START) == 0) {
			//sendMessageWithParm(1, jointRatio);
			const int kMaxSizeOfMessage = 5;
			ubyte nTransmitBuffer[kMaxSizeOfMessage];
			nTransmitBuffer[0] = 1;

			TFileIOResult messageOut = cCmdMessageWriteToBluetooth(2, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			return;
	}
	if (strcmp(command, ARM_EXIT) == 0) {
		//sendMessageWithParm(1, jointRatio);
			const int kMaxSizeOfMessage = 5;
			ubyte nTransmitBuffer[kMaxSizeOfMessage];
			nTransmitBuffer[0] = -1;

			TFileIOResult messageOut = cCmdMessageWriteToBluetooth(2, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			return;
	}
	while(true) {
		nxtDisplayTextLine(0, "PASSED CASES", message);
	}
};
// Pauses the program while we wait for a
// message from the arm controller.
void waitForMessage() {
	while(cCmdMessageGetSize(mailbox1) <= 0) {
		nxtDisplayTextLine(0, "NO MESSAGE", message);
		wait1Msec(100);
	}

	const int kMaxSizeOfMessage = 5;
	ubyte nReceiveBuffer[kMaxSizeOfMessage];

	TFileIOResult messageIn = cCmdMessageRead(nReceiveBuffer, kMaxSizeOfMessage, mailbox1);

	if (nReceiveBuffer[0] == 4) {
		//sendMessageWithParm(1, jointRatio);
			const int kMaxSizeOfMessage = 5;
			ubyte nTransmitBuffer[kMaxSizeOfMessage];
			nTransmitBuffer[0] = 1;
			wait1Msec(PAUSE_TIME);
			if (seeSushi() == true) {
					nTransmitBuffer[0] = 0;
			} else {
				  nTransmitBuffer[0] = 1;
			}

			ClearMessage();
			TFileIOResult messageOut = cCmdMessageWriteToBluetooth(2, nTransmitBuffer, kMaxSizeOfMessage, mailbox1);
			waitForMessage();
	}
	if (nReceiveBuffer[0] == 3) {
		ClearMessage();
		nextBodyCycle();
	}
};

// Parses a BODY command coming from the
// arm controller
void parseMessage() {
	if (message == 3) {
		ClearMessage();
		nextBodyCycle();
	}
}

//--------------------------------------------------Utils

// Initialize system variables
void init() {
	stopWheels();
	setBluetoothOn();
	SensorType[sonarSensor] = sensorSONAR;
};
// Moves forward until we hit sushi
void toNextSushi(){
	moveWheels(speed);

	// Keep going until we see sushi.
	// If certain time elapses, exit program.
	ClearTimer(T1);
	while(seeSushi() != true) {
		if (time1[T1] >= SEARCH_TIME) exit();
	}
	wait1Msec(seeBufferTime);
	distanceFromPlate = time1[T1];

	stopWheels();
};
// Exit the program
// Send message code of -1 to arm to notify it to exit
void exit(){
	powerOff();
};

void moveBackToPlate(){
	moveWheels(-speed);
	wait1Msec(distanceFromPlate);
	stopWheels();
}

//--------------------------------------------------Main
// Runs a single cycle of the sushi program.
//
// 1) Move forward until robot sees sushi.
//	 - If we don't see sushi after a certain period
//     of time, exit the arm and body programs.
// 2) Send a message to arm to pickup and drop sushi.
// 3) Wait for message from arm
// 4) Decide next step depending on message
void nextBodyCycle(){
	toNextSushi();
	updateJointRatio();

	messageArm(ARM_START);
	waitForMessage();
};

task main()
{
	init();
	nextBodyCycle();
	waitForMessage();
}
