#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftWheel,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightWheel,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------Variables

const int speed = 10;

// Bluetooth Messages
const string BODY_START = "BODY_START";
const string ARM_INIT = "ARM_INIT"
const string ARM_START = "ARM_START";
const string ARM_EXIT = "ARM_EXIT";

// RobotC doesn't hoist functions, solve
// this by declaring functions above.
void moveWheels();
void stopWheels();
bool seeSushi();
void messageArm();
void waitForMessage();
void init();
void toNextSushi();
void exit();
void runSushiRobot();
void nextBodyCycle();

//--------------------------------------------------Movement

// Moves the robot forward.
void moveWheels(int power) {
	motor[leftWheel] = power;
	motor[rightWheel] = power;
};
// Stops the robot.
void stopWheels() {
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
};

//--------------------------------------------------Vision

// Returns true if the light sensor detects
// sushi, and false otherwise.
bool seeSushi() {

};

//--------------------------------------------------Bluetooth

// COMMAND    | CODE |  TRANSLATION
// -----------|------|-----------------------
// BODY_START |  +3  |  Run body cycle
// ARM_INIT   |  +2  |  Initialize arm
// ARM_START  |  +1  |  Run arm cycle
// ARM_EXIT   |  -1  |  Exit arm program

// Sends an ARM message to the arm controller.
void messageArm(const string command) {
	switch(command) {
		case ARM_INIT:
			sendMessage(2);
			break;
		case ARM_START:
			sendMessage(1);
			break;
		case ARM_EXIT:
			sendMessage(-1);
			break;
		default:
			break;
	}
};
// Pauses the program while we wait for a
// message from the arm controller.
void waitForMessage() {
	waitUntil(message != 0);
};

// Parses a BODY command coming from the
// arm controller
void parseMessage() {
	if (message == 3) {
		nextBodyCycle();
	}
}

//--------------------------------------------------Utils

// Initialize system variables
void init() {
	messageArm(ARM_INIT);
	stopWheels();
};
// Moves forward until we hit sushi
void toNextSushi(){
	moveWheels(speed);
	waitUntil(seeSushi() == true);
	stopWheels();
};
// Exit the program
// Send message code of -1 to arm to notify it to exit
void exit(){
	messageArm(ARM_EXIT);
	// Wait 1 second to make sure arm receives message.
	wait1Msec(1000);
	powerOff();
};

//--------------------------------------------------Main
// Runs a single cycle of the sushi program.
//
// 1) Move forward until robot sees sushi.
//	 - If we don't see sushi after a certain period
//     of time, exit the arm and body programs.
// 2) Send a message to arm to pickup and drop sushi.
// 3) Wait for message from arm
// 4) Decide next step depending on message
void nextBodyCycle(){
	toNextSushi();

	messageArm(ARM_START);
	waitForMessage();

	parseMessage();
};

task main()
{
	init();
	nextBodyCycle();
}
